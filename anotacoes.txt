Trabalhando com SPRING DATA JPA
1.  Criar um projeto Maven e adicionar o parent, dependencies e build necessários
2.  Como vamos trabalhar com um banco em memória (H2), adicioar a dependência
    Ex.:
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
    </dependency>
3.  Em seguida, em application.properties, colocar as configurações para conexão com o BD. Apesar de ser um BD em memória,
    o processo é o mesmo para qualquer BD. Vide configuração no arquivo.
4.  Como o H2 é um banco em memória, o SB fornece uma opção para rodar um script sql ao carregar o banco e montar toda a
    estrutura de dados necessária.
    4.1.  Dentro de resources, criar um arquivo data.sql com o script sql desejado (ex. create table)
5.  Tendo o banco configurado e o script p/ criar as minhas tabelas, vou criar as classes de entidade correspondentes
    as tabelas. Ver domain.entity: Cliente, Produto, Pedido e ItemPedido
6.  Trabalhando com DAO (Data Access Object) - SEM JPA - Repository renomeado p/ ClientesJdbc
    6.1.  Dentro do meu domain, criar uma package repository e em seguida a classe desejada
    6.2.  Anotar a classe como @Repository, para que o SB leia e carregue corretamente no container
        6.2.1.  Ao anotar com @Repository, além de carregar no container, o SB vai traduzir as exceções de BD e trazê-las
                "bonitinhas" para o java
    6.3.  Criar o método para salvar os dados. Como não estamos utilizando JPA (ainda), vou utilizar uma classe JdbcTemplate
          que vai me auxiliar na persistencia dos dados na base.
        6.3.1.  No meu método, colocar a chamada do .update()
                Ex.:
                jdbcTemplate.update(INSERT, new Object[]{cliente.getNome()});
    6.4.  Para poder testar, como ainda não temos uma API, vou criar um CommandLineRunner p/ executar o método criado em Clientes
    6.5.  Para poder fazer uma query, preciso criar os construtores (padrão e com parâmetros) na classe que eu quero fazer a query,
          neste caso foi a classe Cliente. Isto pq vou pegar o resultSet do meu RowMapper e criar uma nova instancia de Cliente,
          passando os campos mapeados.
    DICA! Quando percebemos que estamos reutilizando alguma coisa, usar Extract Method do IntelliJ e transformá-lo em um método
          separado, como o exemplo do: obterClienteMapper()
    RESUMO: Para trabalhar com jdbcTemplate e fazer um CRUD. Preciso adicionar a dependência ao meu POM, depois no meu repository
            chamar os métodos update(), passando o statement e um objeto new Object[]{...}) ou query(), passando o statement e um
            RowMapper(), para fazer o mapeamento do retorno da query e atribuir a classe.
7.  Trabalhando com DAO (Data Access Object) - COM JPA
    7.1.  Para trabalhar com JPA, a primeira coisa que devemos fazer é adicionar as anotações @Entity e @Table nas classes de entidades
          Isso fará com que o SB escaneie esta classe e coloque no container como uma entidade
    7.2.  Em seguida, adicionar as anotações nas colunas: @Id e @GeneratedValue nas colunas PK e @Column em todas as demais
          O pacote é o javax.persistence import javax.persistence.*;
    7.3.  Quando trabalhamos com JPA, uma vez que informamos quais são as entidades, o próprio já cria as tabelas no H2
          e desta forma não necessitamos do arquivo resources/data.sql com o script de criação de tabelas.
          Para evitar conflitos, o arquivo foi renomeado para desativado_data.sql
    7.4.  No meu Repository, fazer a injeção do EntityManager @Autowired private EntityManager entityManager;
    7.5.  Nos métodos, fazer a anotação @Transactional. É uma necessidade do EntityManager. Importante, precisa ser do pacote: import org.springframework.transaction.annotation.Transactional;
    DICA! Usando o readOnly a pesquisa fica mais rápida pq o JPA não faz cache: @Transactional(readOnly = true)
    7.6.  Utilizar o EntityManager para fazer as operações de persist(), merge(), remove(), find() e createQuery()
        7.6.1.  Quando for uma operação de createQuery, preciso montar o JPQL. Caso precise passar parâmetros, preciso criar uma query tipada
                Exemplos no arquivo Clientes.java
        7.6.2.  Cuidado com as transações transientes. As vezes ao tentar fazer uma operação de delete, a instancia pode estar transiente. Se isso ocorrer, fazer o merge antes
                conforme exemplo na classe Clientes e no método deletar
8.  Trabalhando com o JpaRepository - MELHOR IMPLEMENTAÇÃO
    8.1.  A classe Clientes foi refatorada para se tornar um JpaRepository
    8.2.  Para implementarmos, NÃO DEVEMOS ter a anotação @Repository
    8.3.  Além disso a CLASS tem que virar uma INTERFACE e extender o JpaRepository
        8.3.1.  JpaRepository recebe 2 parâmetros. 1 -> A Entidade; 2 -> O Tipo de dado do ID da entidade
                Ex.:
                public interface Clientes extends JpaRepository<Cliente, Integer> { }
    8.4.  O JpaRepository já tem dentro dele (encapsulado) o EntityManager. É por isso que na implementação não usamos explicitamente o EM
    8.5.  Outras coisas que o JpaRepository já tem encapsulado são os métodos para salvar, obterTodos, etc. Desta forma,
          eu não preciso escrever uma linha de código dentro da interface. Eu simplesmente chamo estes métodos dentro da
          classe ou service que está importando esta interface que extende o JpaRepository
          Ex.: save(); findAll(); delete();
        8.5.1.  IMPORTANTE! Para poder usar o save() e o delete() eu precisei adicionar a dependência do maven CrudRepository.
                Isto porque o JpaRepository extends PagingAndSortingRepository que extends CrudRepository.
        8.5.2.  Alguns métodos mais elaborados como findByNomeLike, precisam ser implementado. Eles são chamados de Query Methods
9.  Query Methods. São métodos que se transformam em uma query. A declaração do nome do método deve respeitar uma certa convenção
    9.1.  Utilizando uma convenção de nome, posso informar no meu método os parâmetros que quero usar para que o Jpa transforme
          o meu método em uma query e assim eu não precise escrever um JPQL.
          Os parâmetros precisam ser passados na ordem que são declarados no nome do método
          Ex.:
          List<Cliente> findByNomeOrId(String nome, Integer id);
          List<Cliente> findByNomeOrIdOrderById(String nome, Integer id);
          Cliente findOneByCpfOrCnpj(String cpf, String cnpj);
          boolean existsByNome(String nome);
    9.2.  Mais informações: https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods
10. @Query. Com esta anotação eu posso escrever querys mais complexas. É a maneira de consultar mais indicada pela documentação de
    referencia do SB.
    10.1. Basta informar a Query que eu desejo, no formato JPQL ou SQL (vide dica a seguir) e passar os parametros.
    DICA! Caso eu queira montar uma query nativa, ao invés de um JPQL em um @Query, eu posso setar o flag para true, conforme exemplo
    EX.:
    public interface UserRepository extends JpaRepository<User, Long> {
      @Query(value = "SELECT * FROM USERS WHERE EMAIL_ADDRESS = :emailAddress", nativeQuery = true)
      User findByEmailAddress(@Param("emailAddress") String emailAddress);
    }
    10.2. Também posso utilizar o @Query p/ fazer modificações como um delete por exemplo. Para isso preciso adicionar a anotação @Modifying
11.  Para exibir o SQL que está sendo gerado/executado pelo Hibernate(JPA) devemos fazer o setup no arquivo de configuração
     application.properties. Vide arquivo.
     Ex.:
     spring.jpa.properties.hibernate.show_sql=true
     spring.jpa.properties.hibernate.format_sql=true
12.  Mapeamentos
    12.1.  @ManyToOne: Normalmente p/ mapear uma FK. Usando no relacionamento muitos p/ um. Informar também o @JoinColumn
        12.1.1.  No @JoinColumn, informar o name da coluna de FK da entidade que estou mapeando (da minha entidade many).
                 Ex.:
                 @JoinColumn(name = "cliente_id")
    12.2.  @OneToMany: Este mapeamento trará uma lista de itens (aqui no caso pedidos) para a entidade (Cliente)
        12.2.1.  Informar o mappedBy, que é o nome da propriedade que foi criada na entidade "many" que leva a FK
                 da minha entidade atual.
                 Ex.:
                 Na entidade many, eu tenho a FK criada para a minha entidade "one"
                 private Cliente cliente;
                 Então na minha entidade "one" eu preciso colocar este nome da propriedade
                 @OneToMany(mappedBy = "cliente")
                 private Set<Pedido> pedidos;
        DICA! Usei Set, mas poderia usar List ou Collection. O Set garante que não terei pedidos repetidos na lista + indicado
        12.2.2.  Após criar o mapeamento, adicionar o getPedidos para este atributo
                 Ex.:
                 public Set<Pedido> getPedidos() {
                     return pedidos;
                 }
        DICA! De preferencia a LocalDate ao invés de Date e/ou Calendar. O LocalDate é mais simples de trabalhar















