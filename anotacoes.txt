Trabalhando com SPRING DATA JPA
1.  Criar um projeto Maven e adicionar o parent, dependencies e build necessários
2.  Como vamos trabalhar com um banco em memória (H2), adicioar a dependência
    Ex.:
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
    </dependency>
3.  Em seguida, em application.properties, colocar as configurações para conexão com o BD. Apesar de ser um BD em memória,
    o processo é o mesmo para qualquer BD. Vide configuração no arquivo.
4.  Como o H2 é um banco em memória, o SB fornece uma opção para rodar um script sql ao carregar o banco e montar toda a
    estrutura de dados necessária.
    4.1.  Dentro de resources, criar um arquivo data.sql com o script sql desejado (ex. create table)
5.  Tendo o banco configurado e o script p/ criar as minhas tabelas, vou criar as classes de entidade correspondentes
    as tabelas. Ver domain.entity: Cliente, Produto, Pedido e ItemPedido
6.  Trabalhando com DAO (Data Access Object) - SEM JPA - Repository renomeado p/ ClientesJdbc
    6.1.  Dentro do meu domain, criar uma package repository e em seguida a classe desejada
    6.2.  Anotar a classe como @Repository, para que o SB leia e carregue corretamente no container
        6.2.1.  Ao anotar com @Repository, além de carregar no container, o SB vai traduzir as exceções de BD e trazê-las
                "bonitinhas" para o java
    6.3.  Criar o método para salvar os dados. Como não estamos utilizando JPA (ainda), vou utilizar uma classe JdbcTemplate
          que vai me auxiliar na persistencia dos dados na base.
        6.3.1.  No meu método, colocar a chamada do .update()
                Ex.:
                jdbcTemplate.update(INSERT, new Object[]{cliente.getNome()});
    6.4.  Para poder testar, como ainda não temos uma API, vou criar um CommandLineRunner p/ executar o método criado em Clientes
    6.5.  Para poder fazer uma query, preciso criar os construtores (padrão e com parâmetros) na classe que eu quero fazer a query,
          neste caso foi a classe Cliente. Isto pq vou pegar o resultSet do meu RowMapper e criar uma nova instancia de Cliente,
          passando os campos mapeados.
    DICA! Quando percebemos que estamos reutilizando alguma coisa, usar Extract Method do IntelliJ e transformá-lo em um método
          separado, como o exemplo do: obterClienteMapper()
    RESUMO: Para trabalhar com jdbcTemplate e fazer um CRUD. Preciso adicionar a dependência ao meu POM, depois no meu repository
            chamar os métodos update(), passando o statement e um objeto new Object[]{...}) ou query(), passando o statement e um
            RowMapper(), para fazer o mapeamento do retorno da query e atribuir a classe.
7.  Trabalhando com DAO (Data Access Object) - COM JPA
    7.1.  Para trabalhar com JPA, a primeira coisa que devemos fazer é adicionar as anotações @Entity e @Table nas classes de entidades
          Isso fará com que o SB escaneie esta classe e coloque no container como uma entidade
    7.2.  Em seguida, adicionar as anotações nas colunas: @Id e @GeneratedValue nas colunas PK e @Column em todas as demais
          O pacote é o javax.persistence import javax.persistence.*;
    7.3.  Quando trabalhamos com JPA, uma vez que informamos quais são as entidades, o próprio já cria as tabelas no H2
          e desta forma não necessitamos do arquivo resources/data.sql com o script de criação de tabelas.
          Para evitar conflitos, o arquivo foi renomeado para desativado_data.sql
    7.4.  No meu Repository, fazer a injeção do EntityManager @Autowired private EntityManager entityManager;
    7.5.  Nos métodos, fazer a anotação @Transactional. É uma necessidade do EntityManager. Importante, precisa ser do pacote: import org.springframework.transaction.annotation.Transactional;
    DICA! Usando o readOnly a pesquisa fica mais rápida pq o JPA não faz cache: @Transactional(readOnly = true)
    7.6.  Utilizar o EntityManager para fazer as operações de persist(), merge(), remove(), find() e createQuery()
        7.6.1.  Quando for uma operação de createQuery, preciso montar o JPQL. Caso precise passar parâmetros, preciso criar uma query tipada
                Exemplos no arquivo Clientes.java
        7.6.2.  Cuidado com as transações transientes. As vezes ao tentar fazer uma operação de delete, a instancia pode estar transiente. Se isso ocorrer, fazer o merge antes
                conforme exemplo na classe Clientes e no método deletar
8.  Trabalhando com o JpaRepository - MELHOR IMPLEMENTAÇÃO
    8.1.  A classe Clientes foi refatorada para se tornar um JpaRepository
    8.2.  Para implementarmos, NÃO DEVEMOS ter a anotação @Repository
    8.3.  Além disso a CLASS tem que virar uma INTERFACE e extender o JpaRepository
        8.3.1.  JpaRepository recebe 2 parâmetros. 1 -> A Entidade; 2 -> O Tipo de dado do ID da entidade
                Ex.:
                public interface Clientes extends JpaRepository<Cliente, Integer> { }
    8.4.  O JpaRepository já tem dentro dele (encapsulado) o EntityManager. É por isso que na implementação não usamos explicitamente o EM
    8.5.  Outras coisas que o JpaRepository já tem encapsulado são os métodos para salvar, obterTodos, etc. Desta forma,
          eu não preciso escrever uma linha de código dentro da interface. Eu simplesmente chamo estes métodos dentro da
          classe ou service que está importando esta interface que extende o JpaRepository
          Ex.: save(); findAll(); delete();
        8.5.1.  IMPORTANTE! Para poder usar o save() e o delete() eu precisei adicionar a dependência do maven CrudRepository.
                Isto porque o JpaRepository extends PagingAndSortingRepository que extends CrudRepository.
        8.5.2.  Alguns métodos mais elaborados como findByNomeLike, precisam ser implementado. Eles são chamados de Query Methods
9.  Query Methods. São métodos que se transformam em uma query. A declaração do nome do método deve respeitar uma certa convenção
    9.1.  Utilizando uma convenção de nome, posso informar no meu método os parâmetros que quero usar para que o Jpa transforme
          o meu método em uma query e assim eu não precise escrever um JPQL.
          Os parâmetros precisam ser passados na ordem que são declarados no nome do método
          Ex.:
          List<Cliente> findByNomeOrId(String nome, Integer id);
          List<Cliente> findByNomeOrIdOrderById(String nome, Integer id);
          Cliente findOneByCpfOrCnpj(String cpf, String cnpj);
    9.2.  Mais informações: https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods
10. @Query. Com esta anotação eu posso escrever querys mais complexas. É a maneira de consultar mais indicada pela documentação de
    referencia do SB.
    10.1. Basta informar a Query que eu desejo, no formato JPQL ou SQL (vide dica a seguir) e passar os parametros.
    DICA! Caso eu queira montar uma query nativa, ao invés de um JPQL em um @Query, eu posso setar o flag para true, conforme exemplo
          EX.:
          public interface UserRepository extends JpaRepository<User, Long> {
            @Query(value = "SELECT * FROM USERS WHERE EMAIL_ADDRESS = :emailAddress", nativeQuery = true)
            User findByEmailAddress(@Param("emailAddress") String emailAddress);
          }
    10.2. Também posso utilizar o @Query p/ fazer modificações como um delete por exemplo. Para isso preciso adicionar a anotação @Modifying
11. Para exibir o SQL que está sendo gerado/executado pelo Hibernate(JPA) devemos fazer o setup no arquivo de configuração
    application.properties. Vide arquivo.
    Ex.:
    spring.jpa.properties.hibernate.show_sql=true
    spring.jpa.properties.hibernate.format_sql=true
12. Mapeamentos
    12.1. @ManyToOne: Normalmente p/ mapear uma FK. Usando no relacionamento muitos p/ um. Informar também o @JoinColumn
        12.1.1. No @JoinColumn, informar o name da coluna de FK da entidade que estou mapeando (da minha entidade many).
                Ex.:
                @JoinColumn(name = "cliente_id")
    12.2. @OneToMany: Este mapeamento trará uma lista de itens (aqui no caso pedidos) para a entidade (Cliente)
        12.2.1. Informar o mappedBy, que é o nome da propriedade que foi criada na entidade "many" que leva a FK
                da minha entidade atual.
                Ex.:
                Na entidade many, eu tenho a FK criada para a minha entidade "one"
                private Cliente cliente;
                Então na minha entidade "one" eu preciso colocar este nome da propriedade
                @OneToMany(mappedBy = "cliente")
                private Set<Pedido> pedidos;
        DICA! Usei Set, mas poderia usar List ou Collection. O Set garante que não terei pedidos repetidos na lista + indicado
        12.2.2. Após criar o mapeamento, adicionar o getPedidos para este atributo
                Ex.:
                public Set<Pedido> getPedidos() {
                    return pedidos;
                }
        DICA! De preferencia a LocalDate ao invés de Date e/ou Calendar. O LocalDate é mais simples de trabalhar
              Ex.:
              Pegando a data: LocalDate.now()
              Pegando a data/hora LocalDateTime.now()
13. Criar os repositorys: Produtos, Pedidos e ItensPedido. A implementação é padrão, apenas conforme ex. abaixo
    Ex.:
    public interface ItensPedido extends JpaRepository<ItemPedido, Integer> { }
14. Fazendo consultas com relacionamento JPA
    14.1. Com @Query. Posso criar um método dentro do meu repository.
        14.1.1. Posso fazer a query usando JPQL
        14.1.2. Como a entidade já está mapeada, não preciso fazer os joins, apenas colocar o fetch, conforme exemplo
                Ex.: Veja que eu só coloco FETCH e o c.pedidos (que é como eu mapeei na entidade Cliente: private Set<Pedido> pedidos;)
                @Query("SELECT c FROM Cliente c LEFT JOIN FETCH c.pedidos WHERE c.id = :id")
                Cliente findClienteFetchPedidos(@Param("id") Integer id);
------------------------------------------------------------------------------------------------------------------------
                                    DESENVOLVIMENTO DE UMA API RESTFUL
------------------------------------------------------------------------------------------------------------------------
15. Criação da @Controller
    15.1. Adicionar a dependência do spring-boot-starter-web (se necessário)
    15.2. Criar uma classe Controller dentro de /rest/controller
    15.3. Anotar a classe como @Controller
    15.4. Definir uma URL base para a API é uma boa prática. Antes do nome da classe usar @RequestMapping("/api/clientes")
        15.4.1. Este valor é opcional. Posso definí-lo diretamente em cima dos métodos da controller
    15.5. Injetar os repositorys ou services na controller
        15.5.1. Aqui foi criado um construtor p/ fazer a injeção, mas na SOMOS não usamos isso. Como é feito na SOMOS?
    15.6. Criando um método GET: @GetMapping
        15.6.1. No método colocar a anotação @GetMapping("consulta-cliente-id/{id}"), seguida do path, com ou sem parâmetros,
                para identificar qué será operação HTTP de GET
            15.6.1.1. Por convenção utilizamos o parâmetro da url com o mesmo alias na @PathVariable
        15.6.2. Em seguida, adicionar @ResponseBody (Se usarmos @RestController ao invés de @Controller não precisamos disso)
            15.6.2.1. Na SOMOS não utilizamos esta anotação. Verificar se é necessário mesmo
        15.6.3. O retorno do meu método DEVE ser um ResponseEntity<T>
        15.6.4. Dentro do método, chamar o repository (ou service) que foi injetado na controller
        15.6.5. No return, quando sucesso e quiser retornar um 200, retornar: ResponseEntity.ok(cliente.get());
                Quando não encontrado, retornar um 404, retornar: ResponseEntity.notFound().build();
            15.6.5.1. cliente.get() para obter o cliente que está dentro do Optional<T>
            15.6.5.2. O ResponseEntity é a resposta que retorno na API. Ele pode ser o Header + Body ou só o Body. ele é
                      muito versátil e posso formatá-lo usando um construtor (nova instancia de ResponseEntity) para voltar
                      o que eu quiser na API.
        15.6.6. Criar um CommandLineRunner para criar e salvar um cliente no H2
        DICA! Como o meu JSON está retornado a lista de pedidos vinculada ao cliente (devido ao mapeamento @OneToMay da entidade)
              Ex.:
              {
                  "id": 2,
                  "nome": "Cicrano",
                  "pedidos": []
              }
              Eu posso colocar uma anotação @JsonIgnore em cima da propriedade mapeada que retorna a lista
              Ex.:
              @JsonIgnore // Para que o meu JSON não retorne a lista de pedidos
              @OneToMany(mappedBy = "cliente")
              private Set<Pedido> pedidos;
    15.7. Criando um método POST: @PostMapping
        15.7.1. No método colocar a anotação @PostMapping("salvar-cliente") seguida do path
        15.7.2. Assim como no GET, colocar o @ResponseBody para que o objeto retornado pelo controller seja automaticamente
                serializado em JSON
        15.7.3. Na assinatura do método, preciso colocar um @RequestBody, para que mapear o HttpRequest e "desserializar"
                o body do HttpRequest em um objeto Java. O Spring automaticamente transforma o JSON em objeto Java usando
                esta anotação
    15.8. Criando um método DELETE: @DeleteMapping
        15.8.1. O @DeleteMapping é igual ao @GetMapping. Preciso informar o path, o parâmetro, o @ResponseBody, etc
        15.8.2. Normalmente quando fazemos a deleção retornamos um: ResponseEntity.noContent().build(), que é um retorno 204 de sucesso
                mas que não retorna nenhum conteúdo, afinal fiz uma exclusão.
    15.9. Criando um método PUT: @PutMapping
        15.9.1. O @PutMapping é indicado para quando vamos fazer uma atualização INTEGRAL dos dados (comparar com @PatchMapping)
                ou seja, os parâmetros não informados serão transformados em nulo.
        15.9.2. Na assinatura do método que vou usar o put, utilizamos 2 parâmetros de entrada. O ID que eu quero atualizar
                e o @RequestBody, que é onde eu recebo os dados
        15.9.3. Neste método eu faço a consulta pelo findById() e salvo usando o .save()
            15.9.3.1. O uso do Optional<T> permite que eu encadeie chamadas, como o .map() por exemplo. Neste .map() posso usar uma
                      lambda p/ setar o id e salvar o cliente no H2 e ainda dar o retorno .noContent()
            DICA! Ao invés de setar atributo por atributo, posso usar o .setId() que ele automaticamente seta todas as propriedades
            15.9.3.2. Para finalizar o uso do .map(), uso o .orElseGet(). O método .orElseGet() recebe um suplier.
                      O suplier é um interface funcional que não recebe parâmetros e retorna qualquer coisa
    15.10.Utilizando o Example e ExampleMatcher
        15.10.1.Este métodos permitem que eu faça consultas dinâmicas sem criá-las no repository
        15.10.2.Faço a denifição do ExampleMatcher, que é a estratégia da pesquisa e o Example recebe o filtro + matcher
                Ex.:
                ExampleMatcher matcher = ExampleMatcher.matching().withIgnoreCase().withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING);
                Example example = Example.of(filtro, matcher);
                return ResponseEntity.ok(clientes.findAll(example));
16. Refaturando a ClienteController em ClienteRestController
    16.1. Ao invés de usar o @Controller é melhor usar a @RestController, pois essa dispensa o uso da @ResponseBody,
          pois essa anotação já tem @Controller e @ResponseBody
    16.2. Outra coisa que foi refatorada no código foi a remoção do ResponseEntity, desta forma foram necessários adicionar a anotação
          @ResponseStatus() em cima do método, passando o HttpStatus de acordo com a resposta desejada.
          Obs. Se eu não informar nada, ele vai voltar 200 para sucesso
          Ex.:
          @ResponseStatus(HttpStatus.CREATED) // volta 201
          @ResponseStatus(HttpStatus.NOT_FOUND) // volta 404
    16.3. Para dar o retorno correto quando houver um erro, usar orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Cliente não encontrado"));










